<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal Shoreline Interactive</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: none; /* feels nicer with the water interaction */
    }
    .hint {
      position: fixed;
      left: 16px;
      bottom: 14px;
      font-size: 12px;
      color: rgba(255,255,255,0.75);
      user-select: none;
      pointer-events: none;
      letter-spacing: 0.2px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Move mouse: water pulls back â€¢ Click the sand text buttons</div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Canvas 2D context not available");
  
    const SAND = "#F2D27A";
    const SAND_DARK = "#C7A85D";
    const WATER = "#1E73D8";
  
    const mouse = { x: 0, y: 0, has: false };
  
    const buttons = [
      { label: "Button 1", w: 140, h: 42, x: 0, y: 0 },
      { label: "Button 2", w: 140, h: 42, x: 0, y: 0 },
      { label: "Button 3", w: 140, h: 42, x: 0, y: 0 },
    ];
  
    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const cssW = canvas.clientWidth || innerWidth;
      const cssH = canvas.clientHeight || innerHeight;
  
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
  
      // draw in CSS pixel coordinates
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  
    window.addEventListener("resize", resize);
    resize();
  
    window.addEventListener("mousemove", (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      mouse.has = true;
    });
    window.addEventListener("mouseleave", () => (mouse.has = false));
  
    window.addEventListener("click", (e) => {
      const x = e.clientX, y = e.clientY;
      for (const b of buttons) {
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
          alert(`${b.label} clicked`);
          break;
        }
      }
    });
  
    function layoutButtons(w, shorelineY) {
      const gap = 26;
      const totalW = buttons.reduce((s, b) => s + b.w, 0) + gap * (buttons.length - 1);
      let x = (w - totalW) / 2;
      const y = shorelineY + 48;
      for (const b of buttons) {
        b.x = x;
        b.y = y;
        x += b.w + gap;
      }
    }
  
    function waterlineY(x, t, w, shorelineY) {
      const waveAmp = Math.max(6, Math.min(14, w * 0.01));
      const wave =
        Math.sin((x / w) * Math.PI * 2.2 + t * 0.0012) * waveAmp +
        Math.sin((x / w) * Math.PI * 5.1 - t * 0.0009) * (waveAmp * 0.35);
  
      let dent = 0;
      if (mouse.has) {
        const dx = x - mouse.x;
        const dy = shorelineY - mouse.y;
        const dist2 = dx * dx + dy * dy;
  
        const sigma = Math.max(140, Math.min(260, w * 0.22));
        const strength = Math.max(70, Math.min(150, w * 0.10));
        dent = -strength * Math.exp(-dist2 / (2 * sigma * sigma));
      }
      return shorelineY + wave + dent;
    }
  
    function roundRect(x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }
  
    function frame(t) {
      try {
        const w = innerWidth;
        const h = innerHeight;
        const shorelineY = h * 0.52;
  
        layoutButtons(w, shorelineY);
  
        // Clear using CSS-pixel space (transform already set)
        ctx.clearRect(0, 0, w, h);
  
        // Sand
        ctx.fillStyle = SAND;
        ctx.fillRect(0, 0, w, h);
  
        // Subtle sand shading
        const g = ctx.createLinearGradient(0, shorelineY, 0, h);
        g.addColorStop(0, "rgba(0,0,0,0.00)");
        g.addColorStop(1, "rgba(0,0,0,0.08)");
        ctx.fillStyle = g;
        ctx.fillRect(0, shorelineY, w, h - shorelineY);
  
        // Sand buttons text
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "600 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        for (const b of buttons) {
          ctx.globalAlpha = 0.22;
          ctx.fillStyle = "#000";
          roundRect(b.x, b.y, b.w, b.h, 14);
          ctx.fill();
  
          ctx.globalAlpha = 1;
          ctx.fillStyle = SAND_DARK;
          ctx.fillText(b.label, b.x + b.w / 2, b.y + b.h / 2 + 1);
          ctx.globalAlpha = 0.65;
          ctx.fillStyle = "#8f7a45";
          ctx.fillText(b.label, b.x + b.w / 2, b.y + b.h / 2);
          ctx.globalAlpha = 1;
        }
        ctx.restore();
  
        // Water
        ctx.save();
        ctx.fillStyle = WATER;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, 0);
  
        const step = Math.max(6, Math.floor(w / 140));
        for (let x = w; x >= 0; x -= step) {
          ctx.lineTo(x, waterlineY(x, t, w, shorelineY));
        }
        ctx.closePath();
        ctx.fill();
  
        // Water edge highlight
        ctx.globalAlpha = 0.18;
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = 0; x <= w; x += step) {
          const y = waterlineY(x, t, w, shorelineY);
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
  
        // Cursor dot
        if (mouse.has) {
          ctx.save();
          ctx.globalAlpha = 0.35;
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(mouse.x, mouse.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      } catch (err) {
        console.error("Render error:", err);
        // If something breaks, at least show sand so it isn't black
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = SAND;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
  
      requestAnimationFrame(frame);
    }
  
    requestAnimationFrame(frame);
  </script>

